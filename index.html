<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Montreal Green Spaces & Tree Map</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>
  
  <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css"/>

  <style>
    /* ------------------------------------------------ */
    /* BASE STYLES                                    */
    /* ------------------------------------------------ */
    body { 
      font-family: Arial, sans-serif; 
      margin:0; 
      background:#f5f0e1; 
      color:#333; 
      display:flex; 
      flex-direction:column; 
      min-height:100vh; 
    }
    .container { width:90%; max-width:1200px; margin:0 auto; padding:20px; }
    header { background:#6a4e3d; color:#fff; padding:18px 0; margin-bottom:8px; }
    header .logo { font-size:1.6rem; text-decoration:none; color:#fff; }
    /* UPDATED NAV */
    nav ul { list-style:none; display:flex; gap:12px; padding:0; margin:12px 0 0 0; justify-content:center; flex-wrap: wrap; }
    nav a { color:#fff; text-decoration:none; padding:6px 10px; border-radius:6px; transition: background 0.2s; }
    nav a:hover { background: rgba(255, 255, 255, 0.15); }
    nav a.active { font-weight:700; background:rgba(255,255,255,0.08); text-decoration:underline; }
    /* END UPDATED NAV */
    main { flex:1; padding-bottom:40px; }
    .tab-content { display:none; }
    .tab-content.active { display:block; }
    .hero { background:#fff5e1; padding:20px; border-radius:10px; text-align:center; margin-bottom:16px; }
    .map-container { 
      position: relative;
      height:75vh; 
      width:100%; 
      border-radius:10px; 
      box-shadow:0 0 10px rgba(0,0,0,0.08); 
    }
    footer { background:#6a4e3d; color:#fff; text-align:center; padding:14px 0; margin-top:20px; }
    .leaflet-control-layers {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 6px;
      padding: 4px;
    }
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.85); 
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000; 
      font-size: 1.2rem;
      color: #6a4e3d;
      font-weight: bold;
      border-radius: 10px; 
      text-align: center;
      padding: 20px;
    }
    
    /* Geocoder Control styling to sit above the map */
    .leaflet-control-geocoder {
        margin-bottom: 8px;
        z-index: 800; 
    }
    .geocoder-control-container {
        display: flex;
        justify-content: center;
        width: 100%;
        margin-bottom: 15px;
    }
    .leaflet-control-geocoder.leaflet-bar {
        min-width: 300px; 
        max-width: 90%;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        border-radius: 8px;
    }
    
    /* NEW CONTENT STYLES */
    .content-box {
        background: #fff;
        padding: 25px;
        border-radius: 10px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        margin-top: 10px;
    }
    .content-box h4 {
        color: #047857;
        border-bottom: 2px solid #e5e7eb;
        padding-bottom: 8px;
        margin-top: 20px;
    }
    .content-box ul {
        list-style-type: disc;
        margin-left: 20px;
    }
  </style>
</head>
<body>
  <header>
    <div class="container">
      <a class="logo" href="#">Montreal Green Spaces & Tree Map</a>
      <nav aria-label="primary">
        <ul>
          <li><a href="#" onclick="switchView('home'); return false;" id="nav-home" class="active">Home</a></li>
          <li><a href="#" onclick="switchView('greenspace'); return false;" id="nav-greenspace">Map View</a></li>
          <li><a href="#" onclick="switchView('information'); return false;" id="nav-information">Information</a></li>
          <li><a href="#" onclick="switchView('glossary'); return false;" id="nav-glossary">Glossary/Sources</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <main class="container" id="main">
    
    <section id="home" class="tab-content active">
      <div class="hero">
        <h2>Montreal Green Spaces & Trees</h2>
        <p>Welcome! This application allows you to explore the green infrastructure and climate vulnerability of Montreal using open data from the City.</p>
        <p>Click on the **Map View** tab to begin exploring trees, parks, flood zones, and urban heat areas.</p>
      </div>
    </section>

    <section id="greenspace" class="tab-content">
      <h3 style="text-align:center">Green Spaces & Tree Map</h3>
      
      <div class="geocoder-control-container">
        </div>
      <div id="greenspace-map" class="map-container"></div>
    </section>
    
    <section id="information" class="tab-content">
        <h3 style="text-align:center">Project Information & Analysis</h3>
        <div class="content-box">
            <p>Use this section to provide details about the data, the project motivation, and any high-level analysis or insights you want to share with the user.</p>

            <h4>Why Green Spaces Matter</h4>
            <p>Urban green spaces and trees are crucial for public health, biodiversity, and climate resilience. They:</p>
            <ul>
                <li>Reduce the **Urban Heat Island** effect, making neighborhoods cooler.</li>
                <li>Manage stormwater runoff and mitigate minor **Flood Risk**.</li>
                <li>Improve air quality and provide habitats for urban wildlife.</li>
            </ul>

            <h4>Map Overlays Explained</h4>
            <p>The layers in the Map View are derived from various datasets:</p>
            <ul>
                <li>**All Trees (Markers):** Individual street trees collected by the City of Montreal (Loaded by default).</li>
                <li>**Green Spaces Boundary:** Boundaries of parks and green areas (Loaded by default).</li>
                <li>**Heatmap Zones:** Areas categorized by potential heat exposure (1 = Coolest, 5 = Hottest). These layers are currently styled with a single color for testing.</li>
                <li>**Flood Zones:** Areas identified as being at higher risk of flooding.</li>
                <li>**Green Priority Zones:** Strategic areas identified by the city for future greening and ecological development.</li>
            </ul>
        </div>
    </section>

    <section id="glossary" class="tab-content">
        <h3 style="text-align:center">Glossary & Data Sources</h3>
        <div class="content-box">
            <p>This is where you can clearly list the source of your data and define key terms used in the map.</p>

            <h4>Data Sources</h4>
            <ul>
                <li>**Tree Inventory:** Source link here.</li>
                <li>**Green Spaces Boundary:** Source link here.</li>
                <li>**Flood Zones:** Source link here.</li>
                <li>**Urban Heat/Heatmap Zones:** Source link here.</li>
                <li>**Green Priority Zones:** Source link here.</li>
            </ul>
            <p style="margin-top: 15px; font-size: 0.9em; color: #555;">*Note: Please replace the "Source link here" text above with actual hyperlinks to the open data portals you used.*</p>

            <h4>Glossary of Terms</h4>
            <ul>
                <li>**GeoJSON:** A standard format for encoding various geographic data structures using JSON.</li>
                <li>**EPSG:2950 (MTM Zone 8):** The projected coordinate system often used by the City of Montreal for spatial data (which requires the coordinate fix in this code).</li>
                <li>**WGS84 (EPSG:4326):** The standard coordinate system (Longitude/Latitude) used by web mapping applications like Leaflet.</li>
            </ul>
        </div>
    </section>
    
  </main>

  <footer>
    <div class="container">Â© 2025 Montreal Green Spaces</div>
  </footer>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.11.0/proj4.js"></script>
  <script src="https://unpkg.com/proj4leaflet/src/proj4leaflet.js"></script>
  <script>
  // ----------------------------------------------------
  // I. CONFIGURATION & GLOBAL STATE
  // ----------------------------------------------------
  
  // ðŸŸ¢ DEFINE THE MONTREAL COORDINATE SYSTEM (EPSG:2950 / MTM Zone 8) ðŸŸ¢
  // This step is crucial for proj4leaflet to understand the Easting/Northing coordinates
  // and correctly transform them to Longitude/Latitude for Leaflet.
  if (typeof proj4 !== 'undefined') {
      proj4.defs(
          "EPSG:2950", 
          "+proj=tmerc +lat_0=0 +lon_0=-73.5 +k=0.9999 +x_0=300000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +type=crs"
      );
      // L.CRS.EPSG2950 is now available for use in GeoJSON options
  }
  
  // Data will be stored here after initial load
  let allTreeData = [];
  let mapInstance = null;
  let treeClusterLayer = null;

  // Define all individual borough CSV files for tree data 
  const BOROUGH_CSVS = {
    'Ahuntsic - Cartierville': './Ahuntsic_Cartierville.csv',
    'CÃ´te-des-Neiges - Notre-Dame-de-GrÃ¢ce': './CDN_NDG.csv',
    'RiviÃ¨re-des-Prairies - Pointe-aux-Trembles': './RDP_PAT.csv',
    'Rosemont - La Petite-Patrie': './Rosemont_Patrie.csv',
    'Saint-LÃ©onard': './Saint_Leonard.csv',
    'Verdun': './Verdun.csv',
    'Ville-Marie': './Ville_Marie.csv',
    'Lachine': './Lachine.csv',
    'Le Plateau-Mont-Royal': './Le_Plateau_MR.csv',
    'Le Sud-Ouest': './Le_Sud_Ouest.csv',
    'Mercier - Hochelaga-Maisonneuve': './Mercier_HM.csv',
    'Pierrefonds - Roxboro': './Pierrefonds_Roxboro.csv',
    'Villeray-Saint-Michel - Parc-Extension': './Villeray_SM_PE.csv',
  };


  const TAB_CONFIG = {
    greenspace: { 
      mapDiv: 'greenspace-map', 
      color: '#047857', // Tree marker color
      tree_csv_files: BOROUGH_CSVS,
      // GeoJSON Overlays
      greenspace_geojson: './Green.geojson',
      flood_geojson: './Flood.geojson',
      heat_geojson: './Heat.geojson', 
      greenprio_geojson: './GreenPrio.json' // Note: This file name extension is fine if it contains GeoJSON data
    },
  };
  
  // Only the optional layers will be explicitly managed in the layer control
  const overlayLayers = {
      "Flood Zones": L.layerGroup(), 
      "Heatmap Zones": L.layerGroup(), 
      "Green Priority Zones": L.layerGroup()
  };

  const mapInstances = {};
  
  // ----------------------------------------------------
  // II. HELPER FUNCTIONS
  // ----------------------------------------------------

  function clearContainer(id) {
    const el = document.getElementById(id);
    if (!el) return;
    el.innerHTML = '';
  }

  function makeDivIcon(color, size=8) {
    return L.divIcon({
      className: 'circle-icon',
      html: '<span style="display:block;width:'+size+'px;height:'+size+'px;'+
            'border-radius:50%;background:'+color+';'+
            'border:1px solid rgba(0,0,0,0.12);box-shadow:0 0 2px rgba(0,0,0,0.2)"></span>',
      iconSize:[size,size],
      iconAnchor:[Math.round(size/2),Math.round(size/2)]
    });
  }

  function updateLoadingStatus(mapDivEl, boroughName) {
    let loader = mapDivEl.querySelector('.loading-overlay');
    if (!loader) {
      loader = document.createElement('div');
      loader.className = 'loading-overlay';
      mapDivEl.appendChild(loader);
    }
    loader.innerHTML = 'Loading Tree Data...<br>Processing: **' + boroughName + '**';
  }

  /**
   * Loads a single CSV file, parses it, and adds the raw data to the global allTreeData array.
   */
  function loadBoroughCsv(boroughName, csvPath) {
    return new Promise((resolve, reject) => {
      Papa.parse(csvPath, {
        download: true, 
        header: true,
        dynamicTyping: true,
        skipEmptyLines: true,
        complete(results) {
          results.data.forEach(row => {
            const lat = row.Latitude ?? row.latitude ?? row.LAT ?? row.lat ?? row.Coord_Y_WGS84 ?? null;
            const lon = row.Longitude ?? row.longitude ?? row.LON ?? row.lon ?? row.Coord_X_WGS84 ?? null;

            if (lat == null || lon == null || isNaN(lat) || isNaN(lon)) return; 
            
            allTreeData.push({
                lat,
                lon,
                borough: boroughName,
                data: row 
            });
          });
          resolve();
        },
        error(err) {
          console.error(`CSV load error for ${boroughName} (${csvPath}):`, err);
          resolve(); 
        }
      });
    });
  }
  
  // ----------------------------------------------------
  // III. TREE DRAWING AND GEOJSON STYLING
  // ----------------------------------------------------
  
  /**
   * Draws all loaded tree data onto the cluster layer.
   */
  function drawAllTrees(trees, clusterLayer, cfg) {
      clusterLayer.clearLayers();
      
      trees.forEach(tree => {
          const marker = L.marker([tree.lat, tree.lon], { icon: makeDivIcon(cfg.color, 8) });

          // Attempt to find species using common column names
          const species = tree.data.Essence_ang ?? tree.data.ESSENCE ?? 'Unknown Species';
          
          // Attempt to find planting date
          const plantedRaw = tree.data.Date_Plantation;
          let planted = 'Unknown Date';
          if (plantedRaw) {
             try {
                const date = new Date(plantedRaw);
                if (!isNaN(date)) {
                    planted = date.toLocaleDateString('en-CA', { year: 'numeric', month: 'short', day: 'numeric' });
                } else {
                    planted = plantedRaw.toString().substring(0, 10);
                }
             } catch(e) {
                 planted = plantedRaw.toString().substring(0, 10);
             }
          }

          
          const popup = `<b>Tree Species: ${species}</b><br>Planted: ${planted}<br>Borough: ${tree.borough}`;
          
          marker.bindPopup(popup);
          clusterLayer.addLayer(marker);
      });
  }

  // NOTE: getHeatmapStyle function has been removed as requested. 
  // A fixed style object is used in the loadGeoJsonLayer call instead.
  
  // ----------------------------------------------------
  // IV. GEOJSON LOADING FUNCTIONS
  // ----------------------------------------------------
  
  /**
   * Function to load GeoJSON data and add it to the map/layer control.
   * It now accepts an optional 'options' object for projection settings (CRS).
   */
  async function loadGeoJsonLayer(map, path, styleFunctionOrObject, popupFunction, layerName, isDefaultLayer=false, options={}) {
      try {
          const response = await fetch(path);
          const contentType = response.headers.get("content-type");
          if (!response.ok) throw new Error(`Failed to load ${layerName}: ${response.statusText}`);
          
          let geoJsonData;
          if (contentType && (contentType.includes("json") || contentType.includes("geo+json"))) {
              geoJsonData = await response.json();
          } else {
              const text = await response.text();
              geoJsonData = JSON.parse(text);
          }
          
          // Determine the style function/object
          const finalStyle = typeof styleFunctionOrObject === 'function' 
                             ? styleFunctionOrObject 
                             : (feature) => styleFunctionOrObject; 

          // Pass the options object here (contains the crs for EPSG:2950)
          const layer = L.geoJSON(geoJsonData, {
              style: finalStyle,
              onEachFeature: (feature, layer) => {
                  if (popupFunction) popupFunction(feature, layer);
              },
              ...options 
          });
          
          if (isDefaultLayer) {
             layer.addTo(map);
             overlayLayers[layerName] = layer;
          } else {
             overlayLayers[layerName] = layer;
          }

      } catch (error) {
          console.error(`Error loading ${layerName} GeoJSON:`, error);
          overlayLayers[layerName] = L.layerGroup(); 
      }
  }

  // ----------------------------------------------------
  // V. MAP INITIALIZATION 
  // ----------------------------------------------------
  
  async function createMapIfNeeded(tabId) {
    if (mapInstances[tabId]) {
      mapInstance = mapInstances[tabId].map;
      treeClusterLayer = mapInstances[tabId].cluster;
      return mapInstance;
    }

    const cfg = TAB_CONFIG[tabId];
    if (!cfg) return null;

    clearContainer(cfg.mapDiv);
    const mapDivEl = document.getElementById(cfg.mapDiv); 
    mapDivEl.innerHTML = '<div class="loading-overlay">Initializing Map...</div>';

    // 1. Initialize Map and Base Layers
    const map = L.map(cfg.mapDiv).setView([45.5019, -73.5674], 11);
    mapInstance = map;

    const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(map);
    const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles &copy; Esri' });
    const terrainLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', { maxZoom: 20, attribution: '&copy; CARTO' });

    const baseLayers = { "Standard Map": osmLayer, "True Satellite": satelliteLayer, "Minimalist Base": terrainLayer };

    // 2. Load Tree Markers Data (Store Globally)
    const treeCluster = L.markerClusterGroup({ maxClusterRadius: 40 });
    treeClusterLayer = treeCluster;
    
    // Reset data and start loading all borough CSVs
    allTreeData = []; 
    const treeLoadPromises = Object.entries(cfg.tree_csv_files).map(([boroughName, csvPath]) => {
      updateLoadingStatus(mapDivEl, boroughName);
      return loadBoroughCsv(boroughName, csvPath); 
    });

    await Promise.all(treeLoadPromises); // Wait for all borough CSVs to load
    
    // 3. Load GeoJSON Overlays
    
    // A. Green Spaces Boundary (DEFAULT LAYER - WGS84 coordinates expected)
    await loadGeoJsonLayer(map, cfg.greenspace_geojson, 
        { color: '#047857', weight: 1.5, fillColor: '#6ee7b7', fillOpacity: 0.6 },
        (feature, layer) => {
            const props = feature.properties;
            const name = props.Nom || 'Unknown Green Space';
            const area = props.SUPERFICIE ? (parseFloat(props.SUPERFICIE) * 10000).toFixed(2) + ' sq. m.' : 'Area Unknown';
            const typo = props.TYPO1 || props.TYPO2 || 'N/A';
            layer.bindPopup(`<b>${name}</b><br>Type: ${typo}<br>Area: ${area}<br>Ownership: ${props.PROPRIETE || 'Unknown'}`);
        }, 
        "Green Spaces Boundary", true, 
        {} 
    );
    
    // B. Flood Zones (OPTIONAL OVERLAY - WGS84 coordinates expected)
    await loadGeoJsonLayer(map, cfg.flood_geojson, 
        { color: '#3b82f6', weight: 2, fillColor: '#60a5fa', fillOpacity: 0.4 },
        (feature, layer) => {
            const zoneName = feature.properties.NAME || feature.properties.RISK || 'N/A';
            layer.bindPopup(`<b>Flood Zone</b><br>Risk Level: ${zoneName}`);
        }, 
        "Flood Zones", false, 
        {} 
    );
    
    // C. Heatmap Zones (OPTIONAL OVERLAY - ðŸŸ¢ EPSG:2950 COORDINATE FIX APPLIED ðŸŸ¢)
    await loadGeoJsonLayer(map, cfg.heat_geojson, 
        { color: '#dc3545', weight: 1, fillColor: '#ffc107', fillOpacity: 0.5 }, // <-- FIXED STYLE for testing
        (feature, layer) => {
            const tempClass = feature.properties.Temp_Class || 'N/A';
            const legend = feature.properties.Legende || 'N/A';
            layer.bindPopup(`<b>Heat Zone</b><br>Class: ${tempClass}<br>Description: ${legend}`);
        }, 
        "Heatmap Zones", false,
        { crs: L.CRS.EPSG2950 } // <-- THIS FIXES THE COORDINATE FLIP/PROJECTION
    );
    
    // D. Green Priority Zones (OPTIONAL OVERLAY - ðŸŸ¢ EPSG:2950 COORDINATE FIX APPLIED ðŸŸ¢)
    await loadGeoJsonLayer(map, cfg.greenprio_geojson, 
        { color: '#9333ea', weight: 2, fillColor: 'none', fillOpacity: 0, dashArray: '8, 4' }, 
        (feature, layer) => {
            // Generic popup, as property names are unknown
            layer.bindPopup(`<b>Green Priority Zone</b><br>Check Layer Details`);
        }, 
        "Green Priority Zones", false,
        { crs: L.CRS.EPSG2950 } // <-- THIS FIXES THE COORDINATE FLIP/PROJECTION
    );
    
    // 4. Initial Tree Draw and Add to Map (DEFAULT LAYER)
    drawAllTrees(allTreeData, treeCluster, cfg);
    treeCluster.addTo(map);

    // 5. Add Address Search (Geocoder)
    const geocoderContainer = document.querySelector('.geocoder-control-container');
    const geocoder = L.Control.geocoder({
        defaultMarkGeocode: false, 
        placeholder: 'Search Address in Montreal...',
    });

    geocoder.on('markgeocode', function(e) {
        const bbox = e.geocode.bbox;
        const poly = L.polygon([
            [bbox.getSouthEast().lat, bbox.getSouthEast().lng],
            [bbox.getNorthEast().lat, bbox.getNorthEast().lng],
            [bbox.getNorthWest().lat, bbox.getNorthWest().lng],
            [bbox.getSouthWest().lat, bbox.getSouthWest().lng]
        ]);
        
        map.eachLayer(function(layer) {
            if(layer.options && layer.options.isAddressMarker) {
                map.removeLayer(layer);
            }
        });

        map.fitBounds(poly.getBounds(), { padding: [50, 50] }); 
        L.marker(e.geocode.center, { 
            icon: makeDivIcon('#e3000b', 12),
            isAddressMarker: true 
        })
        .bindPopup(`<b>${e.geocode.name}</b>`).addTo(map).openPopup(); 
    }).addTo(map);
    
    // Move the geocoder control element into the dedicated container
    const geocoderControlEl = map.getContainer().querySelector('.leaflet-control-geocoder');
    if (geocoderControlEl) {
        geocoderControlEl.parentNode.removeChild(geocoderControlEl);
        geocoderContainer.appendChild(geocoderControlEl); 
    }


    // 6. Setup Layer Control
    const finalOverlays = {
        "Trees (Markers)": treeCluster,
        "Green Spaces Boundary": overlayLayers["Green Spaces Boundary"], 
        "Flood Zones": overlayLayers["Flood Zones"],
        "Heatmap Zones": overlayLayers["Heatmap Zones"],
        "Green Priority Zones": overlayLayers["Green Priority Zones"] 
    };
    Object.keys(finalOverlays).forEach(key => {
        if (!finalOverlays[key]) delete finalOverlays[key];
    });


    L.control.layers(baseLayers, finalOverlays).addTo(map);

    // 7. Finalize Map View
    if (treeCluster.getLayers().length > 0) {
        map.fitBounds(treeCluster.getBounds(), { maxZoom: 15, padding:[20,20] });
    } else {
        map.setView([45.5019, -73.5674], 11);
    }
    
    const loader = mapDivEl.querySelector('.loading-overlay');
    if (loader) loader.remove();


    mapInstances[tabId] = { map, cluster: treeCluster };
    return map;
  }

  // ----------------------------------------------------
  // VI. VIEW SWITCHING
  // ----------------------------------------------------

  function switchView(tabId) {
    const all = ['home','greenspace','information','glossary'];

    all.forEach(id => {
      const el = document.getElementById(id);
      if (!el) return;
      if (id === tabId) el.classList.add('active'); else el.classList.remove('active');
    });

    ['nav-home','nav-greenspace','nav-information','nav-glossary'].forEach(id => {
      const el = document.getElementById(id);
      if (!el) return;
      const target = id.replace('nav-','');
      if (target === tabId) el.classList.add('active'); else el.classList.remove('active');
    });

    if (tabId === 'greenspace') {
      const map = createMapIfNeeded(tabId);
      if (map) setTimeout(()=>{ try{ map.invalidateSize(); } catch(e){ console.warn(e); } }, 120);
    }
  }

  window.switchView = switchView; 
  document.addEventListener('DOMContentLoaded', ()=>switchView('home'));
  </script>
</body>
</html>
